---
title: "Evolutionary Optimization"
author: "Max Conway"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Evolutionary Optimization}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

This document gives a demonstration of evolutionary optimization in Flux Balance analysis.

## Preparation

Install the FluxBalanceAnalyzeR package (and some dependencies):
```{r, eval = FALSE}
install.packages('devtools')
devtools::install_github('maxconway/FluxBalanceAnalyzeR')
```

Load the packages we'll be using:
```{r}
library(FluxBalanceAnalyzeR)
library(plyr)
library(dplyr)
library(gurobi)
library(ggplot2)
```


## Exploration
Load some example data, and look at it:
```{r}
data("ecoli_core")
ecoli_core
```
This table is a list of all the reactions in the model: their names and equations, and parameters like the upper and lower bounds.

First, we want to evaluate the model as it is, to check that it is working. While the current table format is suitable for viewing and editing the model, it's not the correct one for evaluating it. To evaluate it we must transform it into the input format for the Gurobi linear programming library, and then run it using the Gurobi function:
```{r}
result <- ecoli_core %>%
  reactiontbl_to_gurobi() %>%
  gurobi()
```

It works! You should get an optimal objective of 0.9.

To explore the results, we can view the resulting fluxes alongside the model:
```{r}
ecoli_core %>% mutate(result$x)
```
This shows us that D-Glucose uptake, and the internal succinate dehydrogenase reaction are limiting.

## Synthetic objective
If we want to investigate the production of some biotechnically useful component, we can do this by fixing the biomass production at the maximum level (since the cell will always want to produce maximum biomass), and then seeing how much of the synthetic objective can be produced. To do this, we create a new copy of the model, fix it's biomass output, and then optimize for acetate excretion:
```{r}
mod2 <- ecoli_core

mod2[mod2$abbreviation=='Biomass_Ecoli_core_w/GAM','lowbnd']<-0.8739
mod2[mod2$abbreviation=='EX_ac(e)','obj_coef']<-1
mod2[mod2$abbreviation=='Biomass_Ecoli_core_w/GAM','obj_coef']<-0

result2 <- mod2 %>%
reactiontbl_to_gurobi() %>%
gurobi()

mod2 %>% mutate(result2$x)
```

We can see that we still don't get any acetate production.

## Genetic engineering
To try to increase acetate production, we could try knockouts or knockdowns of reations in the model. To test these modifications we could just repeat the producedure above manually, but it's much easier if we create a function that can take a model, perform the two optimizations, and then produce the output.
```{r}
culture <- function(mod1){
  result1 <- mod1 %>%
    reactiontbl_to_gurobi() %>%
    gurobi(params=list(OutputFlag=0))
  
  if(result1$status!='OPTIMAL'){
    return(data_frame(biomass=0, acetate=0))
  }

  mod2 <- mod1

  mod2[mod2$abbreviation=='Biomass_Ecoli_core_w/GAM','lowbnd'] <- 
    result1$x[mod1$abbreviation=='Biomass_Ecoli_core_w/GAM']
  mod2[mod2$abbreviation=='EX_ac(e)','obj_coef'] <- 1
  mod2[mod2$abbreviation=='Biomass_Ecoli_core_w/GAM','obj_coef'] <- 0

  result2 <- mod2 %>%
    reactiontbl_to_gurobi() %>%
    gurobi(params=list(OutputFlag=0))
  
  data_frame(biomass=result2$x[mod2$abbreviation=='Biomass_Ecoli_core_w/GAM'], 
             acetate=result2$x[mod1$abbreviation=='EX_ac(e)'])
}

culture(ecoli_core)
```

The function seems to work, so let's try a modification:
```{r}
mod <- ecoli_core
mod[mod$abbreviation=='EX_co2(e)',c('lowbnd','uppbnd')] <- 0
culture(mod)
```
Excellent - it produces acetate now, but significantly less biomass. But are there better modifications? 

Maybe we should knock down Co2 excretion, rather that completely removing it?
```{r}
mod <- ecoli_core
mod[mod$abbreviation=='EX_co2(e)',c('lowbnd','uppbnd')] <- 
  mod[mod$abbreviation=='EX_co2(e)',c('lowbnd','uppbnd')] * 0.01
culture(mod)
```
Unsurprisingly, this produces intermediate values of both biomass and acetate.

## Automation
We've tried ad-hoc modifications, but to properly explore a large number of possibilities, we should take a more structured approach.

The following code tries knockouts for each reaction in the model, and combines them into a data frame:
```{r}
results <- ldply(ecoli_core$abbreviation, function(ko){
  mod <- ecoli_core
  mod[mod$abbreviation==ko,c('lowbnd','uppbnd')] <- 0
  culture(mod)
})
```

We can then use a scatter plot to show what is known as the Pareto front - the tradeoff between the objectives:
```{r}
library(ggplot2)
ggplot(results, aes(x=acetate, y=biomass)) + geom_point()
```
This shows us that there are plenty of uninteresting results with biomass or acetate of 0, but also some interesting ones with acceptable production of both.

What if we want to repeat this sweep with different levels of knockdown? Or to try combinations of knockouts? You might want to try modifying the above code to try this, but the number of possibilities is too large to do an exhaustive sweep. This is a great job for an optimization technique such as an evolutionary algorithm.

## Evolutionary optimization
Let's start with a simple example of using an evolutionary technique, with one by one on/off switches of genes, and a simple objective of maximizing the product of biomass and acetate:
```{r, eval = FALSE}
bestgenomes <- matrix(TRUE,1,nrow(ecoli_core))

log <- rdply(100,{
  genomes <- bestgenomes[rep(1:nrow(bestgenomes), length.out=100)]
  flips <- raply(20, {sample(c(-1,rep.int(1,nrow(ecoli_core)-1)))})
  genomes <- (genomes-0.5)*flips+0.5
  genomes <- rbind(genomes, bestgenomes)
  
  results <- adply(genomes, 1, function(ko){
    mod <- ecoli_core
    mod[,'lowbnd'] <- mod[,'lowbnd']*ko
    mod[,'uppbnd'] <- mod[,'uppbnd']*ko
    culture(mod)
  }) %>%
    mutate(score=rank(biomass*acetate, ties.method='random'))
  
  bestgenomes <- genomes[results$rank<10,]
  return(results)
}, .progress='text', .id='generation')
```

We can plot the optimization log, to find that the simple producedure shown doesn't really do much better than the parameter sweep.
```{r, eval = FALSE}
ggplot(log, aes(x=biomass, y=acetate, colour=generation)) + geom_point()
```

Try modifying the code to try to deal with continuous knockdowns, to get a better result.













